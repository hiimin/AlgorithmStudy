# 개념 정리

##  메모리 영역\(code, data, stack, heap\)

{% embed url="https://selfish-developer.com/entry/%EC%8A%A4%ED%83%9D-%ED%9E%99-%EC%BD%94%EB%93%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%98%81%EC%97%AD" %}

{% embed url="https://sfixer.tistory.com/entry/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%ADcode-data-stack-heap" %}



## PCB\(Process Control Block\)

*  운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳, 프로세스의 상태 정보를 저장하는 구조체
*  프로세스 상태 관리와 문맥교환\(Context Switching\)을 위해 필요
* PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지된다.

CPU에 급한 프로세스가 처리해달라고 긴급 요청\(인터럽트\)이 왔을 때 기존에 작업하던 프로세스를 어딘가에 임시 저장을 해놓아야 된다. 즉 프로세스에 관한 정보들을 저장할 어딘가의 공간이 필요한데 그게 PBC이다. 어떤 프로세스인지, 이 프로세스가 어디까지 실행됐는지, 현재 상태는 어떤지, 우선순위, 입출력 상태 정보, 레지스터 관련 정보, 할당된 자원, CPU 사용 시간 등을 저장함.

![](../.gitbook/assets/image%20%282%29.png)

## Interrupt

 '끼어들다', '중단시키다' 정도의 의미로 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행중인 작업을 중단하고 발생된 상황을 처리한 후 다시 실행중인 작업으로 복귀하는 것. 외부/내부 인터럽트는 CPU의 하드웨어 신호에 의해 발생하고 소프트웨어 인터럽트는 명령어의 수행에 의해 발

###  외부 인터럽

*  전원 이상 인터럽트 : 정전, 파워 이상 등
*  기계 착오 인터럽트 : cpu의 기능적인 오류
*  외부 신호 인터럽트
  * 타이머에 의한 인터럽트 : Preemptive\(선점\) 개념. 자원이 할당된 시간이 다 끝난 경우
  * 키보드로 인터럽트 키를 누른 경우 : 대표적으로 Control + Alt + Delete
  * 외부장치로부터 인터럽트 요청이 있는 경우 : I/O 인터럽트랑 다른 개념
* 입출력 인터럽트\(I/O 인터럽트\)
  * 입출력장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야 할 경우
  * 입출력 데이터에 이상이 있는 경우

###  내부 인터럽트

*  잘못된 명령이나 잘못된 데이터를 사용할때 발생하며 Trap이라 부른다.
* 프로그램 검사 인터럽트\(Program check interrupt\)
  * Division by zero
  * Overflow/Underflow
  * 기타 exception

###  소프트웨어 인터럽트\(SVC : SuperVisor Call\)

*  사용자가 프로그램을 실행시키거나 감시프로그램\(Supervisor\)을 호출하는 동작을 수행하는 경우
*  소프트웨어 이용중 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 등의 동작이 수행된다.

###  인터럽트 동작 순서

1.  인터럽트 요청
2.  프로그램 실행 중단
3.  현재의 프로그램 상태 보존 : PCB
4.  인터럽트 처리 루틴 실행 : 인터럽트를 요청한 장치를 식별한다.
5.  인터럽트 서비스 루틴 실행 : 인터럽트 원인을 파악하고 실질적인 작업을 수행한다. 처리기 레지스터 상태를 보존한다. 서비스 루틴 수행 중 우선순위가 더 높은 인터럽트가 발행하면 또 재귀적으로 1~5를 수행한다.
6.  상태 복구 : 인터럽트 발생 시 저장해둔 PCB를 다시 복구한다.
7.  중단된 프로그램 실행 재개 : PCB의 값을 이용해 이전에 수행중이던 프로그램을 재개한다.

## IPC\(Inter Process Communication\)

 프로세스는 독립적으로 실행된다. 즉, 독립 되어있다는 것은 다른 프로세스에게 영향을 받지 않는다고 말할 수 있다. \(스레드는 프로세스 안에서 자원을 공유하므로 영향을 받는다\) 이런 독립적 구조를 가진 **프로세스 간의 통신**을 해야 하는 상황이 있을 것이다. 이를 가능하도록 해주는 것이 바로 IPC 통신이다. 프로세스는 커널\(운영체제의 핵심적인 부분으로, 다른 모든 부분에 여러 기본적인 서비스를 제공해줌\)이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있게 된다.

###  1. PIPE\(익명 PIPE\)

 파이프는 두개의 프로세스를 연결하게 되고, 하나의 프로세스는 데이터를 쓰기만, 다른 하나는 데이터를 읽기만 할 수있다. 한쪽 방향으로만 통신이 가능한 파이프의 특징 때문에 Half-Duplex\(반이중\) 통신이라고 부르기도 한다. PIPE와 같이 반이중 통신의 경우 하나의 통신선로는 읽기나 쓰기 중 하나만 가능하므로 만약 읽기와 쓰기, 즉 송/수신을 모두 하기 원한다면 두개의 파이프를 만들어야 가능해진다. 매우 간단하게 사용할 수 있는 장점이 있고, 단순한 데이터 흐름을 가질 땐 파이프를 사용하는 것이 효율적이다. 하지만 전이중 통신을 위해 2개를 만들어야 할 때는 구현이 복잡해지는 단점이 있다.

![](../.gitbook/assets/image%20%2820%29.png)

###  2. Named PIPE\(FIFO\)

 익명 파이프는 통신을 할 프로세스가 명확하게 알 수 있는 경우 사용한다. 예를 들어 자식과 부모 프로세스 간 통신의 경우 사용할 수 있으며, Named PIPE는 전혀 모르는 상태의 프로세스들 사이의 통신의 경우 사용한다. 부모 프로세스와 무관하게 전혀 다른 모든 프로세스들 사이에서 통신이 가능한데 그 이유는 프로세스간 통신을 위해 이름이 있는 파일을 사용하기 때문이다. Named PIPE의 생성은 mkfifo를 통해서 이뤄지는데, mkfifo가 성공하면 명명된 파일이 생성된다. Named PIPE도 읽기/쓰기 동시에 불가능하지만 통신선로가 파일로 존재하므로 하나를 읽기 전용으로 열고 다른 하나를 쓰기 전용으로 열어서 이러한 read/write 문제를 해결할 수 있다. 전이중 통신을 위해서는 결국 PIPE와 같이 두개의 FIFO 파일이 필요하게 된다.

![](../.gitbook/assets/image%20%2824%29.png)

###  3. Message Queue

 Queue\(큐\)는 선입선출의 자료구조를 가지는 통신설비로 커널에서 관리한. 입출력 방식으로 보자면 위의 Named PIPE와 동일하다고 볼 수 있다. Named PIPE와 다른 점이라면 Name PIPE가 데이터의 흐름이라면 메시지 큐는 **메모리 공간**이라는 점이다. 파이프가 아닌, 어디에서나 물건을 꺼낼 수 있는 컨테이너 벨트라고 보면 된다. 메시지 큐의 장점은 컨테이너 벨트가 가지는 장점을 그대로 가지게 된다. 컨테이너 벨트에 올라올 물건에 라벨을 붙이면 동시에 다양한 물건을 다룰 수 있는 것과 같이, **메시지 큐에 쓸 데이터에 번호를 붙임**으로써 여러 개의 프로세스가 동시에 데이터를 쉽게 다룰 수 있.

![](../.gitbook/assets/image%20%2858%29.png)

### 4. Shared Memory\(공유메모리\)

파이프, 메시지 큐가 통신을 이용한 설비라면, **공유 메모리는 데이터 자체를 공유하도록 지원하는 설비**다.

프로세스의 메모리 영역은 독립적으로 가지며 다른 프로세스가 접근하지 못하도록 반드시 보호되야한다. 하지만 다른 프로세스가 데이터를 사용하도록 해야하는 상황도 필요할 것이다. 파이프를 이용해 통신을 통해 데이터 전달도 가능하지만, 스레드처럼 메모리를 공유하도록 해준다면 더욱 편할 것이다.

공유 메모리는 **프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용**해준다.

프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 된다.

* **중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중에 가장 빠르게 작동함**

![](../.gitbook/assets/image%20%2877%29.png)

###  5. Memory Map

 공유 메모리처럼 메모리를 공유해준다. 메모리 맵은 **열린 파일을 메모리에 맵핑시켜서 공유**하는 방식이다. \(즉 공유 매개체가 파일+메모리\)

주로 파일로 대용량 데이터를 공유해야 할 때 사용한다.

![](../.gitbook/assets/image%20%2823%29.png)

###  6. Socket

 네트워크 소켓 통신을 통해 데이터를 공유한다. 네트워크 소켓을 이용하여 Client - Server 구조로 데이터를 통신하며, 원격에서 프로세스간 데이터를 공유 할 때 사용한다.  서버 단에서는 bind, listen, accept를 해주어 소켓 연결을 위한 준비를 해주어야 하고 , 클라이언트 단에서는 connect를 통해 서버에 요청하며, 연결이 수립 된 이후에는 Socket을 send함으로써 데이터를 주고 받게 된. 연결이 끝난 후에는 반드시 Socket 을 close\(\)해주어야 한다.

![](../.gitbook/assets/image%20%2861%29.png)

*  이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 세마포어와 뮤텍스를 사용한다.\(공유된 자원에 한번에 하나의 프로세스만 접\)

##  상호배제\(Mutual exclusion\)

 상호배제는 병행성을 보장하기 위한 것으로 어떤 특정한 시점에 하나의 자원에는 하나의 프로세스만 접근할 수 있게 나머지의 접근은 배제시키는 것을 뜻한다. 동시성 프로그래밍의 가장 큰 숙제는 '공유자원 관리'일 것이다. 공유자원을 안전하게 관리하기 위해서는 상호배제를 달성하는 기법이 필요하다. 뮤텍스와 세마포어는 이를 위해 고안된 기법으로 서로 다른 방식으로 상호배제를 달성한다.

###  Mutex

 한 쓰레드, 프로세스에 의해 소유될 수 있는 Key를 기반으로 한 상호배제 기법. 뮤텍스는 화장실이 하나 뿐이 없는 식당과 비슷하다. 화장실을 가려고 하는데 카운터에 키가 있으면 화장실에 사람이 없다는 뜻이고 그 열쇠를 이용해 화장실에 들어갈 수 있다. 키가 없다면 카운터에서 대기하면서 키가 생길때까지 기다려야 한다. 뮤텍스는 Key에 해당하는 어떤 오브젝트가 있으면 이 오브젝트를 소유한 쓰레드 or 프로세스만이 공유자원에 접근할 수 있다.

###  Semaphore

 현재 공유자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법으로 세마포어는 손님이 화장실을 좀 더 쉽게 이용할 수 있는 레스토랑이라고 할 수 있다. 세마포어를 이용하는 레스토랑의 화장실에는 여러 개의 칸이 있다. 그리고 화장실 입구에는 현재 화장실의 빈 칸 개수를 보여주는 전광판이 있어서 화장실에 가고 싶다면 입구에서 빈 칸의 개수를 확인하고 빈 칸이 1개 이상이라면 빈칸의 개수를 하나 뺀 다음에 화장실로 입장해야 한다. 그리고 나올 때 빈 칸의 개수를 하나 더해준다. 모든 칸에 사람들이 들어갔을 경우 빈 칸의 개수는 0이 되며 이 때 화장실에 들어가고자 하는 사람이 있다면 빈칸의 개수가 1로 바뀔때까지 기다려야 한다.

## next deadlock

{% embed url="https://jhnyang.tistory.com/102" %}



