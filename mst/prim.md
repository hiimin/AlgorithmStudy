# Prim

 

![](../.gitbook/assets/image%20%2815%29.png)

크루스칼 알고리즘은 최소의 가중치를 갖는 간선을 선택했고, 임의의 간선을 선택하는 과정에서 트리가 마구 생성되었다. 프림 알고리즘 역시 가중치가 낮은 간선부터 선택하지만, 트리를 마구 여기저기서 생성하는 것이 아니라, 트리를 유지하면서 완성시키는 성질을 가지고 있다.

##  알고리즘

1.  시작 단계에서는 시작 정점만이 MST집합에 포함된다.
2.  앞 단계에서 만들어진 MST집합에 포함 되지 않고, 인접한 정점들 중에서 최소 간선으로 연결된 정점을 선택하여 트리를 확장한다.\(즉, 가장 낮은 가중치를 먼저 선택한다.\)
3. 위의 과정을 트리가 \(N-1\)개의 간선을 가질 때까지 반복한다.

##  시간복잡도

 우선순위 큐 자료구조와 인접리스트를 사용하면 우선순위 큐의 push/pop 연산에 O\(log V\)의 시간이 걸리고, 모든 간선을 확인하기 위해 우선순위 큐에 간선을 push하는 연선이 E번, 확인을 위해 pop하는 연산이 E번 수행되므로 O\(E\)가 된다. 따라서, 전체적으로 **O\(ElogV\)**의 시간이 걸린다.

## Kruskal vs Prim

* 프림은 정점 위주, 크루스칼은 간선 위주
* 프림은 시작점을 정하고, 시작점에서 가까운 정점을 선택하면서 트리를 구성하므로 그 과정에서 사이클을 이루지 않지만 크루스칼은 시작점을 따로 정하지 않고 최소 비용의 간선을 차례로 대입 하면서 트리를 구성하기 때문에 사이클이 이루어지는지 항상 확인해야한다.
* 프림의 경우 최소 거리의 정점을 찾는 부분에서 자료구조의 성능에 영항을 받는다.
* 크루스칼은 간선을 기준으로 정렬하는 과정이 오래 걸린다.
* 그래프 내에서 적은 숫자의 간선만을 가지는 '희소 그래프\(Spare Graph\)'의 경우 Kruskal 알고리즘이 적합
* 그래프에 간이 많이 존재하는 '밀집 그래프\(Dense Graph\)'의 경우 Prim 알고리즘이 적합하다.
* Kruskal : O\(E logE\)
* Prim : O\(V^2+E\) → O\(E logV\)

