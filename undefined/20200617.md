# 20200617

##  알고리즘

###  다익스트라 알고리즘

 다익스트라 알고리즘의 아이디어는 최단거리는 최단거리로 이루어져 있다는 생각에서부터 출발한다.

 예를들어 1번 정점에서 2번 정점으로 가는 최단 경로가 1 - 4 - 3 - 2로 형성되어 있다고 가정한다면, 이때 1번 정점에서 4번 정점으로 가는 최단거리와 1번 정점에서 3번 정점으로 가는 최단거리는 1번 정점에서 2번 정점으로 가는 최단거리 내에 포함된다.

 만약 1번 정점에서 4번 정점으로 가는 최단경로가 1- 5 - 4 라면 1번 정점에서 2번 정점으로 가는 최단 경로가 1- 5 -4 -3 -2 가 되어야 하므로 모순이 된다.

 따라서 이 아이디어에 기반하여 정점 V로 부터 최단거리를 구하는 과정에 구해지는 정점들을 이용하여 계속 최단거리를 구해나간다.

 우선 다익스트라 알고리즘을 위하여 최단거리를 기록할 배열과 후보가 될 수 있는 간선중 최고로 작은 간선을 빠르게 뽑아낼 수 있는 힙\(heap\) 자료구조가 필요하다.

 동작원리는 v부터 시작하여 최단거리를 갱신해 나가는데 이 때 어떤 정점으로의 최단거리를 구해냈을 때 그 정점에 연결된 간선\(다른 정점으로 최단경로의 후보가 될 수 있는 간선\)을 전부 힙에 삽입해주고 힙에서 가장 작은 정보부터 보면서 이미 최단거리가 계산 된 정점이라면 건너뛰는 방식으로 구해나간다.

{% embed url="https://sungjk.github.io/2016/05/13/Dijkstra.html" %}

*  단일 시작점 최단경로 알고리즘으로 시작 정점 s에서부터 다른 정점들까지의 최단 거리를 계산한다.
* 우선순위 큐에 정점의 번호와 함께 지금까지 찾아낸 해당 정점까지의 최단 거리를 쌍으로 넣는다.
* 우선순위 큐는 정점까지의 최단 거리를 기준으로 정점을 배열함으로써, 아직 방문하지 않은 정점 중 시작점으로부터의 거리가 가장 가까운 점을 찾는 과정을 간단하게 해준다.
* 각 정점까지의 최단거리를 저장하는 배열 dist\[\]를 유지하며, 정점을 방문할 때마다 인접한 정점을 모두 검사한다.
* 간선 \(u,v\)를 검사했는데 v가 만약 아직 방문하지 않은 정점이라면 u까지의 최단거리에 \(u,v\)의 가중치를 더해 v까지의 경로의 길이를 찾는다.
* 이것이 지금까지 우리가 찾은 최단 거리라면 dist\[v\]를 갱신하고 \(dist\[v\] , v\)를 큐에 넣는다.

```java
dist[] INF로 초기화
Q에 (시작 정점 s, 거리 0) 추가
dist[s] = 0;

while(Q가 안비었다면){
	Q에서 거리가 가장 작은 정점 u를 poll

	for(u에 인접한 간선 (u, v) 방문){
		if(dist[v] > dist[u] + w(u, v)){
			dist[v] = dist[u] + w(u,v);
			Q.add(v, dist[v]);
		}
	}
}
```

####  시간 복잡도

1.다익스트라는 모든 간선을 검사한다. 따라서 O\(E\)

2.다음으로 우선순위 큐에 원소를 넣고, 삭제하는데 드는 총 시간

 우선순위 큐에 들어갈 수 있는 최대 점의 수는 O\(E\)이다.\(모든 간선이 검사될 때마다 최대로 한 번 들어갈 수 있다.\) 여기에 추가 또는 삭제하는 시간은 O\(logE\)이므로, 전체 시간복잡도는 O\(ElogE\)이다.

 따라서 총 시간복잡도는 O\(E + ElogE\) = O\(ElogE\)이고,

 보통 간선의 개수 E가 V^2보다 작으므로 O\(ElogV\)라고 볼 수있다.

##  운영체제

###  동기\(Synchronous\)

 요청과 그 결과가 동시에 일어난다는 뜻이며, 어떤 객체 또는 함수 내부에서 다른 함수를 호출했을때 이 함수의 결과를 호출한 쪽에서 처리하면 동기.

 요청과 그 결과가 동시에 일어나서 요청을 하면 바로 그 요청한 자리에서 결과가 주어지며 시간이 얼마나 걸리든 상관 안하고 요청한 그 자리에서 결과를 주겠다는 약속같은 것이다. 즉, 요청과 결과가 한자리에서 동시에 일어난다.

###  비동기\(Asynchronous\)

 요청과 그 결과가 동시에 일어나지 않는다는 뜻이며, 어떤 객체 또는 함수 내부에서 다른 함수를 호출했을 때 이 함수의 결과를 호출한 쪽에서 처리하지 않으면 비동기

 요청과 결과가 동시에 일어나지 않아 바로 결과가 주어지지 않고 나중에 처리된다.

####  \* 동기와 비동기

 동기/비동기는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사다. 호출되는 함수에게 callback을 전달해서, 호출되는 함수의 작업이 완료되면 호출되는 함수가 전달받은 callback을 실행하고, 호출하는 함수는 작업 완료 여부를 신경쓰지 않으면 Asynchronous다.

 호출하는 함수가 호출되는 함수의 작업 완료 후 리턴을 기다리거나, 또는 호출되는 함수로부터 바로 리턴 받더라도 작업 완료 여부를 호출하는 함수 스스로 계속 확인하며 신경쓰면 Synchronous다.

###  블로킹\(Blocking\)

 자신의 수행결과가 끝날 때까지 제어권을 갖고 있는 것을 의미

 블로킹은 말 그대로 작업이 중단된다는 의미. 네트워크 통신에서 요청이 발생하고 완료될 때까지 모든 일을 중단한 상태로 대기해야 하는 것을 블로킹 방식이라 한다.\(블로킹 방식의 소켓통신은 결과가 올 때까지 다른 작업을 중단하고 하염없이 기다리게 됨\)

###  논블로킹\(non-blocking\)

 자신이 호출되었을 때 제어권을 바로 자신을 호출한 쪽으로 넘기며, 자신을 호출한 쪽에서 다른 일을 할 수 있도록 하는 것을 의

 논블로킹은 말 그대로 중단되지 않는다는 말. 통신이 완료 될 때까지 중단되는 블로킹의 반대 개념이다. 논블로킹 방식은 아무래도 통신이 완료될 때까지 기다리지 않고 다른 작업을 수행할 수 있으므로 경우에 따라 효율이나 반응속도가 더 뛰어나다.

#### \* 블로킹, 논블로킹

 블로킹/논블로킹은 호출되는 함수가 바로 리턴하느냐 마느냐가 관심사다. 호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있으면 NonBlocking이다. 그렇지 않고 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 Blocking이다.

{% embed url="https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/" %}

### NonBlocking & Sync

 NonBlocking은 바로 return을 해서 제어권을 준다고 했고,  Sync는 작업완료여부를 호출한 쪽에서 신경을 쓴가 했다. 호출을 하고 바로 반환이 되고 다른일을 수행한다. 이후에 작업이 완료되었는지 계속 물어보는 일을 추가로 수행하는 것이 NonBocking & Sync이다.

### Blocking & Async

 우선 Blocking은 작업이 완료될때까지 제어권을 호출된 쪽에서 가지고 있고, Async는 작업 완료 여부를 호출된 쪽에서 신경을 쓴다. 제어권이 없는 상태에서 결과만 기다리는 Blocking & Sync와 별 차이가 없는 것 같다. 이 방식은 특별한 장점이 없어 일부러 사용할 필요는 없다고 한다. 보통 NonBlocking & Async 방식을 쓰는데 그 과정중 하나라도 Blocking이 포함되면 의도치않게 Blocking & Async로 작동한다고 한다,

