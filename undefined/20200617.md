# 20200617

##  알고리즘

###  다익스트라 알고리즘

 다익스트라 알고리즘의 아이디어는 최단거리는 최단거리로 이루어져 있다는 생각에서부터 출발한다.

 예를들어 1번 정점에서 2번 정점으로 가는 최단 경로가 1 - 4 - 3 - 2로 형성되어 있다고 가정한다면, 이때 1번 정점에서 4번 정점으로 가는 최단거리와 1번 정점에서 3번 정점으로 가는 최단거리는 1번 정점에서 2번 정점으로 가는 최단거리 내에 포함된다.

 만약 1번 정점에서 4번 정점으로 가는 최단경로가 1- 5 - 4 라면 1번 정점에서 2번 정점으로 가는 최단 경로가 1- 5 -4 -3 -2 가 되어야 하므로 모순이 된다.

 따라서 이 아이디어에 기반하여 정점 V로 부터 최단거리를 구하는 과정에 구해지는 정점들을 이용하여 계속 최단거리를 구해나간다.

 우선 다익스트라 알고리즘을 위하여 최단거리를 기록할 배열과 후보가 될 수 있는 간선중 최고로 작은 간선을 빠르게 뽑아낼 수 있는 힙\(heap\) 자료구조가 필요하다.

 동작원리는 v부터 시작하여 최단거리를 갱신해 나가는데 이 때 어떤 정점으로의 최단거리를 구해냈을 때 그 정점에 연결된 간선\(다른 정점으로 최단경로의 후보가 될 수 있는 간선\)을 전부 힙에 삽입해주고 힙에서 가장 작은 정보부터 보면서 이미 최단거리가 계산 된 정점이라면 건너뛰는 방식으로 구해나간다.

{% embed url="https://sungjk.github.io/2016/05/13/Dijkstra.html" %}

*  단일 시작점 최단경로 알고리즘으로 시작 정점 s에서부터 다른 정점들까지의 최단 거리를 계산한다.
* 우선순위 큐에 정점의 번호와 함께 지금까지 찾아낸 해당 정점까지의 최단 거리를 쌍으로 넣는다.
* 우선순위 큐는 정점까지의 최단 거리를 기준으로 정점을 배열함으로써, 아직 방문하지 않은 정점 중 시작점으로부터의 거리가 가장 가까운 점을 찾는 과정을 간단하게 해준다.
* 각 정점까지의 최단거리를 저장하는 배열 dist\[\]를 유지하며, 정점을 방문할 때마다 인접한 정점을 모두 검사한다.
* 간선 \(u,v\)를 검사했는데 v가 만약 아직 방문하지 않은 정점이라면 u까지의 최단거리에 \(u,v\)의 가중치를 더해 v까지의 경로의 길이를 찾는다.
* 이것이 지금까지 우리가 찾은 최단 거리라면 dist\[v\]를 갱신하고 \(dist\[v\] , v\)를 큐에 넣는다.

```java
dist[] INF로 초기화
Q에 (시작 정점 s, 거리 0) 추가
dist[s] = 0;

while(Q가 안비었다면){
	Q에서 거리가 가장 작은 정점 u를 poll

	for(u에 인접한 간선 (u, v) 방문){
		if(dist[v] > dist[u] + w(u, v)){
			dist[v] = dist[u] + w(u,v);
			Q.add(v, dist[v]);
		}
	}
}
```

####  시간 복잡도

1.다익스트라는 모든 간선을 검사한다. 따라서 O\(E\)

2.다음으로 우선순위 큐에 원소를 넣고, 삭제하는데 드는 총 시간

 우선순위 큐에 들어갈 수 있는 최대 점의 수는 O\(E\)이다.\(모든 간선이 검사될 때마다 최대로 한 번 들어갈 수 있다.\) 여기에 추가 또는 삭제하는 시간은 O\(logE\)이므로, 전체 시간복잡도는 O\(ElogE\)이다.

 따라서 총 시간복잡도는 O\(E + ElogE\) = O\(ElogE\)이고,

 보통 간선의 개수 E가 V^2보다 작으므로 O\(ElogV\)라고 볼 수있다.

##  운영체제

###  동기\(Synchronous\)

 요청과 그 결과가 동시에 일어난다는 뜻이며, 어떤 객체 또는 함수 내부에서 다른 함수를 호출했을때 이 함수의 결과를 호출한 쪽에서 처리하면 동기.

 요청과 그 결과가 동시에 일어나서 요청을 하면 바로 그 요청한 자리에서 결과가 주어지며 시간이 얼마나 걸리든 상관 안하고 요청한 그 자리에서 결과를 주겠다는 약속같은 것이다. 즉, 요청과 결과가 한자리에서 동시에 일어난다.

###  비동기\(Asynchronous\)

 요청과 그 결과가 동시에 일어나지 않는다는 뜻이며, 어떤 객체 또는 함수 내부에서 다른 함수를 호출했을 때 이 함수의 결과를 호출한 쪽에서 처리하지 않으면 비동기

 요청과 결과가 동시에 일어나지 않아 바로 결과가 주어지지 않고 나중에 처리된다.

####  \* 동기와 비동기

 동기/비동기는 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사다. 호출되는 함수에게 callback을 전달해서, 호출되는 함수의 작업이 완료되면 호출되는 함수가 전달받은 callback을 실행하고, 호출하는 함수는 작업 완료 여부를 신경쓰지 않으면 Asynchronous다.

 호출하는 함수가 호출되는 함수의 작업 완료 후 리턴을 기다리거나, 또는 호출되는 함수로부터 바로 리턴 받더라도 작업 완료 여부를 호출하는 함수 스스로 계속 확인하며 신경쓰면 Synchronous다.

###  블로킹\(Blocking\)

 자신의 수행결과가 끝날 때까지 제어권을 갖고 있는 것을 의미

 블로킹은 말 그대로 작업이 중단된다는 의미. 네트워크 통신에서 요청이 발생하고 완료될 때까지 모든 일을 중단한 상태로 대기해야 하는 것을 블로킹 방식이라 한다.\(블로킹 방식의 소켓통신은 결과가 올 때까지 다른 작업을 중단하고 하염없이 기다리게 됨\)

###  논블로킹\(non-blocking\)

 자신이 호출되었을 때 제어권을 바로 자신을 호출한 쪽으로 넘기며, 자신을 호출한 쪽에서 다른 일을 할 수 있도록 하는 것을 의

 논블로킹은 말 그대로 중단되지 않는다는 말. 통신이 완료 될 때까지 중단되는 블로킹의 반대 개념이다. 논블로킹 방식은 아무래도 통신이 완료될 때까지 기다리지 않고 다른 작업을 수행할 수 있으므로 경우에 따라 효율이나 반응속도가 더 뛰어나다.

#### \* 블로킹, 논블로킹

 블로킹/논블로킹은 호출되는 함수가 바로 리턴하느냐 마느냐가 관심사다. 호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있으면 NonBlocking이다. 그렇지 않고 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 Blocking이다.

{% embed url="https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/" %}

### NonBlocking & Sync

 NonBlocking은 바로 return을 해서 제어권을 준다고 했고,  Sync는 작업완료여부를 호출한 쪽에서 신경을 쓴가 했다. 호출을 하고 바로 반환이 되고 다른일을 수행한다. 이후에 작업이 완료되었는지 계속 물어보는 일을 추가로 수행하는 것이 NonBocking & Sync이다.

### Blocking & Async

 우선 Blocking은 작업이 완료될때까지 제어권을 호출된 쪽에서 가지고 있고, Async는 작업 완료 여부를 호출된 쪽에서 신경을 쓴다. 제어권이 없는 상태에서 결과만 기다리는 Blocking & Sync와 별 차이가 없는 것 같다. 이 방식은 특별한 장점이 없어 일부러 사용할 필요는 없다고 한다. 보통 NonBlocking & Async 방식을 쓰는데 그 과정중 하나라도 Blocking이 포함되면 의도치않게 Blocking & Async로 작동한다고 한다,

##  컴네

###  유니캐스트\(Unicast\)

 유니캐스트는 정보를 전송하기 위한 프레임에 자신의 MAC주소와 목적지 MAC 주소를 첨부하여 전송하는 방식을 말한다. 어떤 시스템이 유니캐스트 방식으로 데이터를 전송하게 되면 같은 네트워크에 있는 모든 시스템들은 그 MAC 주소를 받아서 자신의 MAC 주소와 비교 후 자신의 MAC주소와 같지 않다면 프레임을 버리고 같다면 프레임을 받아서 처리하게 된다. 유니캐스트 방식은 가장 많이 사용하는 방식으로 한 개의 목적지 MAC 주소를 사용하고 CPU 성능에 문제를 주지 않는 방식이다.

###  브로드캐스트\(Broadcast\)

 브로드캐스트 방식은 로컬 네트워크에 연결되어 있는 모든 시스템에게 프레임을 보내는 방식을 말한다. 브로드캐스트 방식의 경우 브로드캐스트용 주소가 미리 정해져있고, 수신 받는 시스템은 이 주소가 오면 패킷을 자신의 CPU로 전송하고 CPU가 패킷을 처리하는 방식이다. 모든 시스템에게 패킷이 전송되므로 트래픽이 증가하고 CPU도 패킷을 처리해야 하므로 성능에 저하가 생긴다. 브로드캐스트 방식은 통신하고자 하는 시스템의 MAC 주소를 알지 못하는 경우, 네트워크에 있는 모든 시스템에게 알리는 경우, 라우터끼리 정보를 교환하거나 새로운 라우터를 찾는 경우 등에 이용된다.

###  멀티캐스트\(Multicast\)

 멀티캐스트는 네트워크에 연결되어 있는 시스템 중 일부에게만 정보를 전송하는 것으로 특정 그룹에 속해 있는 시스템에게만 한 번에 정보를 전송할 수 있는 방법을 말한다. 멀티캐스트는 라우터가 멀티캐스트를 지원해야만 사용 가능하다는 단점이 있다.

 그룹 통신을 위하여 다중 수신자들에게 동일한 데이터를 전송하고자 할 경우 유니캐스트 전송을 이용한다면 전송하고자 하는 데이터 패킷을 다수의 수신자에게 각각 여러 번 전송해야 하며, 이러한 동일한 패킷의 중복 전송으로인해 네트워크의 효율이 저하된다. 또한 수신자 수가 증가할 경우 이러한 문제점은 더 커지게 된다. 반면 멀티캐스트 전송이 지원되면 송신자는 여러 수신자에게 한번에 메시지가 전송되도록 하여 데이터의 중복 전송으로 인한 네트워크 자원 낭비를 최소화 할 수 있게 된다.

 멀티캐스트 전송이 일반적인 유니캐스트 인터넷 응용분야와 다른 점은 우선 그 전송 패킷에 있다. 일반적으로 TCP/IP 상의 인터넷 응용 프로그램은 데이터의 송신자가 이를 수신할 수신자의 인터넷 주소를 전송 패킷의 헤더에 표시해 패킷에 전송한다. 그러나 멀티캐스트 전송을 위해서는 헤더에 수신자의 주소 대신 수신자들이 참여하고 있는 그룹 주소를 표시하여 패킷을 전송한다.

####  멀티캐스트 특징

*  멀티캐스트 그룹 단위로 묶어 그 그룹의 Host 들은 동시에 데이터를 받을 수 있다.
* UDP를 사용하여 전송함으로 신뢰성을 보장받지는 못한다.
* Client에서 멀티캐스트를 사용하는 Application을 시작하면 멀티캐스트 IP 주소와 멀티캐스트 MAC 주소를 라우터에 등록함으로 멀티캐스트 그룹에 등록된다.
* 하나의 Client 에서 여러 멀티캐스트 주소를 수용할 수 있다. 즉 여러 가지 멀티캐스트 데이터를 동시에 받을 수 있다.
* Server가 멀티캐스트 주소로 데이터를 전송 중에 있을 때 중간에  Cllient가 끼어들어도 처음부터 데이터를 받을 수 없고 중간부터 데이터를 받게 된다.

####  멀티캐스트 IP 주소 체계

 224.0.0.0 ~ 239.255.255.255 범위를 갖는 Class D IP 주소를 사용한다.

####  멀티캐스트 Protocol

 어떤 장비와 멀티캐스트 정보를 교환하느냐에 따라 세가지 프로토콜로 나눌 수 있다.

* IGMP : 호스트와 라우터 간 멀티캐스트 정보를 교환하는 프로토콜
* CGMP, IGMP Snooping : 라우터와 스위치 간 멀티캐스트 정보를 교환하는 프로토콜
* Multicasting Routring Protocol : 라우터와 라우터 간 멀티캐스트 정보를 교환하는 프로토콜

![](../.gitbook/assets/image%20%28130%29.png)

### ARP\(Address Resolution Protocol\)

 받는 pc의 MAC 주소는 모르고 IP 주소만 알고있을 때 받는 PC의 MAC 주소를 알기 위해 브로트캐스트를 날린다. 즉 같은 네트워크 안에서 "누구 이런 IP 주소 가지신분?" 이렇게 외친다. 그럼 해당 PC는 자신의 MAC 주소를 전달해준다. 결국 IP 주소를 MAC 주소로 바꾸는 과정, 얻어내는 과정 이를 ARP라고 한다.

####  동작 과정

1.  송신자는 목적지 IP주소는 알고 있으나, 물리주소는 모름
2. 물리주소를  알아내기 위해 ARP 요청 메시지 생성
3. 요청미시지를 데이터링크 계층으로 전달, 프레임 생성\(송신자 물리주소를 발신지 주소, 수신자 물리주소를 브로드캐스트 주소로 지정\)
4. 모든 호스트나 라우터는 이 프레임을 수신하여 자신의 ARP로 전달
5. 요청 메시지에 해당되는 호스트나 라우터만 ARP 응답 메시지 생성\(자신의 물리 주소를 포함하는 응답 메시지\)
6. ARP 응답메시지를 유니캐스트로 ARP 요청 메시지를 보낸 송신자에게 전송\(유니캐스트를 이용하는 이유는 송신자가 요청메시지에 물리주소를 포함했기 때문\)
7. 송신자는 ARP 응답메시지를 받고 목적지 물리주소 획득
8. 목적지에게 전송할 IP 데이터그램을 획득한 물리주소를 이용해 프레임으로 캡슐화
9. 캡슐화된 프레임을 유니캐스트로 목적지로 전송

####  과정 요약

1. ARP Cache 테이블에서 B\(목적지\)의 주소가 있는지 확인
2. B의 주소가 없을 경우 네트워크 상에 브로드 캐스트로 ARP Request를 날림
3.  B는 자신의 주소이므로 자신의 ARP Table에 A\(송신자\)의 주소를 추가한 후 유니캐스트로 ARP Reply 응답을 한다.
4. A는 B로부터 받은 IP주소를 ARP Table에 추가한 후 ARP Process를 종료한다.



