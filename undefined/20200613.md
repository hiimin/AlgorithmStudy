# 20200613

## 컴

## 흐름 제어

수신측과 송신측의 데이터 처리 속도 차이를 해결하기 위한 기법. 송신측의 전송량이 수신측의 처리량보다 많을 경우, 전송된 패킷은 수신측의 큐를 넘어서 손실될 문제가 발생할 수 있기 때문에 송신측의 패킷 전송량을 제어하게 된다.

### 흐름제어 방법

1. 정지-대기\(stop and wait\) 
   1. 매번 전송한 패켓에 대한 응답을 받아야만 그 다음 패킷을 전송할 수 있다.
   2. 구조가 간단한 대신, 하나를 주고 하나를 받기 때문에 비효율적이다.
2. 슬라이딩 윈도우\(sliding window\) - 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법이다. 이처럼 슬라이딩 윈도우 기법을 통하여 송신 버퍼의 범위는 수신 측의 여유 버퍼 공간을 반영하여 동적으로 바뀜으로써 흐름제어를 수행한다.
   1. 윈도우는 전송, 수신 스테이션 양쪽에서 만들어진 버퍼\(buffer\)의 크기이다.
   2. 윈도우의 크기 = 가장 최근 ack로 응답한 프레임의 수 - 이전에 ack프레임을 보낸 프레임의 수
   3. 슬라이딩 윈도우 기법은 stop and wait 기법의 비효율성을 개선한 기법이다.
   4. ack 프레임을 수신하지 않더라도 여러개의 프레임을 연속적으로 전송할 수 있다.

![](../.gitbook/assets/image%20%28117%29.png)

## 혼잡제어

혼잡제어는 송신측의 데이터 전달과 네트워크의 데이터처리 속도 차이를 해결하기 위한 기법이다.

송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 하지만 이러한 네트워크 상의 라우터가 항상 한가로운 상황은 아니다. 만약, 한 라우터에게 데이터가 몰릴 경우 다시 말해 혼잡할 경우, 라우터는 자신에게 온 데이터를 모두 처리할 수 없다. 그렇게 되면 호스트들은 또 다시 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실을 발생시킨다. **따라서, 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 는 보내는 데이터의 전송 속도를 강제로 줄이게 된다.**

### 혼잡제어 방법

1. AIMD **-** AIMD\(Additive Incread / Multiplicative Decrease\)라고 불리며, 합 증가 / 곱 감소라고 부른다.

   처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기\(단위 시간내에 보내는 패킷의 수\)를 1씩 증가시켜 가면서 전송하는 방법이다. 만일 패킷 전송을 실패하거나 일정한 시간을 넘으면 패킷 전송 속도를 절반으로 줄이게 된다.

   이 방식은 **공평한 방식**이다. 이 방식을 사용하는 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만 시간이 흐르면 **평형 상태**로 수렴하게 되는 특징이 있다.

   **문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하며 오랜 시간이 걸리게 되고 네트워크가 혼잡해지는 상황을 미리 감지하지는 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.**

2. 슬로우 스타트\(Slow Start\) - AIMD 방식은 네트워크의 수용량 주변에서는 효율적으로 작동하지만 처음에 전송 속도를 오리는 데 걸리는 시간이 너무 길다는 단점이 있다.

   Slow Start 방식을 AIMD 방식과 마찬가지로 패킷을 하나씩 보내는 것부터 시작하고 이 방식은 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 Window Size를 1씩 늘린다. 즉, 한 주기가 지나면 Window size가 2배가 된다.

   따라서 전송 속도는 AIMD와는 다르게 지수 함수꼴로 증가하게 된다. 대신 **혼잡 현상이 발생하면 Window Size를 1로 떨어뜨리게 된다.**

   처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있으므로 혼잡 현상이 발생하였던 Window Size의 절반까지는 이전처럼 지수 함수 꼴로 Window Size를 증가시키고 그 이후부터는 완만하게 1씩 증가시키는 방식이다.

   1. 초기 혼잡 window size 1로 전송 = 전송 호스트는 하나의 패킷만 전송
   2. 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 2로 하여 전송
   3. 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 4로 하여 전송
   4. 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 8로 하여 전송

   * 미리 정해진 임계 값\(threshold\)에 도달할 때까지 윈도우의 크기를 2배씩 증가시킨다.
   * Slow Start란 이름을 사용하지만, 매 전송마다 두 배씩 증가하기 때문에 전송되어지는 데이터의 크기는 지수 함수적으로 증가한다.
   * 전송되어지는 데이터의 크기가 임계 값에 도달하면 **혼잡 회피** 단계로 넘어간다.

3. 혼잡 회피\(Congestion Avoidance\) - 윈도우의 크기가 임계 값에 도달한 이후에 데이터의 손실이 발생할 확률이 높아지게 된다. 이는 데이터를 전송함에 있어서 조심하는 단계이다.

   전송한 데이터에 대한 ack를 받으면 윈도우의 크기를 1씩 증가시킨다. 전송하는 데이터의 증가를 왕복시간 동안에 하나씩만 증가시킨다.

   * 수신 호스트로부터 일정 시간 동안까지 ack를 수신하지 못하는 경우
     * 타임아웃의 발생
     * 네트워크에 혼잡이 발생했다고 인식
     * 윈도우의 크기를 즉, 세그먼트의 수를 1로 줄임
     * 동시에 임계 값을 패킷 손실이 발생하였을 때의 윈도우 크기의 반으로 줄임

4. 빠른 회복\(Fast Recovery\) - 빠른 회복은 Congesion이 발생했을 때 window size를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다. 이는 AIMD의 AI 즉, Additive Increase 하는 방법이다.

   Fast Recovery를 적용하면 혼잡 상황을 한 번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.

5. 빠른 재전송\(Fast Retransmission\) - 3개의 연속된 중복 ack를 수신하는 경우에 패킷의 손실로 간주하여 타임아웃이 발생하기 전에 해단 패킷을 **재전송**한다. 그리고 이러한 현상이 일어난 것은 약간의 혼잡이 발생한 것으로 간주하여 Window Size를 반으로 줄인다.

   가장 기본적인 혼잡 제어 방법은 AIMD와 Slow Start를 상황에 맞게 조합하는 것

![AIMD](../.gitbook/assets/image%20%28119%29.png)

{% embed url="https://evan-moon.github.io/2019/11/26/tcp-congestion-control/" %}

## 오류제어

오류 제어 기법은 오류 검출과 재전송을 포함한다. 프레임이 손상되었거나 손실되었을 경우 재전송을 통해 오류를 복구하는데 오류 제어 기법은 흐름 제어 기법과 관련이 되어있다. stop and wait는 stop and wait로, sliding window는 GBn\(Go Back n\)또는 SR\(Selective Reject\)로 구현한다.

### 오류 검출

TCP를 사용하는 송수신 측이 오류를 파악하는 방법은 크게 두 가지로 나누어진다. 수신 측이 송신 측에게 명시적으로 NACK\(부정응답\)을 보내는 방법, 그리고 송신 측에게 ACK\(긍정응답\)가 오지 않거나, 중복된 ACK가 계속해서 오면 오류가 발생했다고 추정하는 방법이다.

### 오류제어 방법

1. Stop and Wait

   응답이 올 때까지 대기하고 있다가 다음 데이터를 보내는 방식이다.

![](../.gitbook/assets/image%20%28114%29.png)

2. Go Back N 

Go Back N 방법은 데이터를 연속적으로 보내다가 그 중 어느 데이터부터 오류가 발생했는지를 검사하는 방식이다.

Go Back N 방식을 사용하면 데이터를 연속적으로 보낸 후 한개의 ACK나 NACK만을 사용하여 수신 측의 처리 상황을 파악할 수 있으므로, 연속적으로 데이터를 보낼 수 있는 흐름 제어 방식인 슬라이딩 윈도우에 적합하다.

![](../.gitbook/assets/image%20%28116%29.png)

위 그림을 보면 수신 측이 4번 데이터부터 에러가 발생함을 감지하고 송신측에게 4번부터 다시 보내달라고 하고 있다. Go back N 방식에서 수신 측이 4번 데이터에서 에러가 발생했음을 감지하면, 4번 데이터 이후 자신이 받았던 모든 데이터를 폐기하고 송신 측에게 NACK를 보내게 된다. 즉, 송신 측은 수신측으로 NACK를 받고나면 오류가 발생한 4번 데이터와 그 이후 전송했던 모든 데이터를 다시 전송해줘야 한다는 말이 된다.

3. Selective Repeat

Selective Repeat은 말 그대로 선택적인 재전송을 의미한다. Go Back N 방법도 Stop and Wait에 비하면 많이 효율적인 방법이지만, 에러가 발생하면 그 이후에 정상적으로 전송되었던 데이터까지 모두 폐기 처분되어 다시 전송해야 한다는 비효율이 아직 존재한다. 그래서 나온 방식이 에러난 데이터만 재전송해줘 방식인 것이다.

![](../.gitbook/assets/image%20%28115%29.png)

 굉장히 효율적이고 좋기만 한 것 같지만 Stop and Wait와 Go Back N 방식과 다르게, 이 방식을 사용하는 수신 측의 버퍼에 쌓인 데이터가 연속적이지 않다는 단점이 존재한다. 위 예시만 봐도 수신 측의 버퍼에는 0,1,2,3,4,5 가 순차적으로 들어있는 것이 아니라, 중간에 폐기 처분된 4를 제외한 0,1,2,3,5 만 버퍼에 존재할 것이기 때문이다. 이때 송신 측이 4를 재전송하게 되면 수신측은 이 데이터를 버퍼 중간 어딘가에 끼워 넣어서 데이터를 정렬해야 한다.

 이때 같은 버퍼 안에서 데이터를 정렬할 수는 없으니, 별도의 버퍼가 필요하게 된다. 결국 재전송이라는 과정이 빠진 대신 재정렬이라는 과정이 추가된 것인데, 이 둘 중에 재전송이 좀 더 이득인 상황에서는 Go Back N 방식을, 재정렬이 좀 더 이득인 상황에서는 Selective Repeat 방식을 사용하면 된다.

##  운영체제

##  메모리 단편화

 RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용 가능한 메모리가 충분히 존재하지만 할당\(사용\)이 불가능한 상태이다.

###  내부 단편화

 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 상황

EX\) 메모장 실행시 메모리가 1kb만 필요하지만 4kb를 할당 받았을 경우 내부 단편화가 3kb만큼 생긴 것

###  외부 단편화

 메모리가 할당이 되고 해제가 되는 작업이 반복될 때 작은 단위의 메모리가 띄엄띄엄 존재하게 되는데 빈 메모리의 전체 공간은 충분한 양이지만 실제로 사용할 수 없는 경

###  페이징 기법

 프로세스를 일정한 크기인 페이지로 잘서 메모리에 적재하는 방식이다. 

 프로세스가 적재되는 물리 주소 공간이 연속적이지 않아도 적재를 허용한다는 이점을 가진 메모리 관리 기법이다. 페이징은 세그먼테이션과 달리 외부 단편화를 방지하지만 내부 단편화가 발생한다.

![](../.gitbook/assets/image%20%28113%29.png)

###  세그먼테이션

 페이징은 프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당하였다. 반면에 세그먼테이션은 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치하는 것을 말한다. 내부 단편화는 해결하지만 외부 단편화가 발

 세그먼테이션은 프로세스를 세그먼트\(segment\)의 집합으로 만들고, 각 세그먼트의 크기는 일반적으로 같지 않다. 프로세스를 code + data + stack으로 나누는 것 역시 세그먼테이션의 모습이다. 

![](../.gitbook/assets/image%20%28118%29.png)

###  세그먼테이션과 페이징

 현재 대부분은 페이징 기법을 사용한다. 그 이유는 세그먼테이션에는 치명적인 단점이 있기 때문이다. 

 메모리 할당을 처음 시작할 때 다중 프로그래밍에서의 문제는 크기가 서로 다른 프로세스로 인해 여러 크기의 hole이 발생한다. 이로 인해 어느 hole에 프로세스를 할당하는 것에 대한 최적화 알고리즘이 존재하지 않고, 외부 단편화로 인해 메모리 낭비가 크다고 했었다.

 세그먼테이션도 똑같은 문제점이 발생한다. 왜냐하면 세그먼테이션은 논리적인 단위로 나누기 때문에 세그먼트의 크기가 다양하다. 이로 인해 다양한 크기의 hole이 발생하므로 같은 문제가 발생한다.

 결론적으로 세그먼테이션은 보호와 공유에서 효율적이고, 페이징은 외부 단편화 문제를 해결할 수 있다. 그러므로 두 가지를 합쳐서 사용하는 방법이 나왔다. 두 장점을 합치기 위해서는 세그먼트를 페이징 기법으로 나누는 것이다.

 하지만 이 역시 단점이 존재한다. 세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 두번 변해야한다. 즉 cpu에서 세그먼트 테이블에서 주소 변환을 하고, 그 다음 페이지 테이블에서 또 주소 변환을 해야한다.

## 알고리즘

### Quick Sort

* Quick sort 설명\(pseudo code\)

 분할정복법으로 pivot이라는 기준을 정해서 pivot보다 클 경우 오른쪽 아니면 왼쪽으로 나누고, 나눈 배열을 다시 pivot으로 다누면서 정렬하는 방법을 말한다.

```java
quick sort(int array[], int start, int end){
    if(start >= end){
        return;
    }
    
    int pivot = array[end];
    int i = start - 1;
    for(int j = start; j < end; j++){
        if(array[j] < pivot){
            i++;
            swap(array[i], array[j]);
        }
    }
    
    swap(array[i + 1], pivot);
    
    quick sort(array, start, i);
    quick sort(array, i + 2, end);
}
```

* Merge sort와 비교

 두 정렬 다 평균 시간복잡도가 nlogn이지만 Merge sort는 나누고 다시 합병하는 과정에서 배열의 처음부터 끝까지 모두 골고루 접근하지만, Quick sort는 pivot으로 나누고 나눈 배열에만 접근하기때문에 캐시 적중률이 높아져서 더 효율적이다.

* stable sort를 사용하기 적절한 상황

 stable sort란 값이 같을 경우 현재의 순서를 유지하면서 정렬된 방법이다. 두개 이상의 값으로 정렬할 경우에 사용될 수 있다. 예를 들어 카드를 정렬 할 경우 먼저 숫자 기준으로 정렬 후 모양을 기준으로 정렬 하려고 할 때, stable하지 않으면 숫자를 기준으로 정렬 후 모양을 기준으로 정렬하면 모양이 같을 경우 기존의 순서를 유지하지 않기 때문에 숫자 순으로 된 정렬이 깨질 수 있다. 이때 stable한 정렬을 사용하면 숫자와 모양 순서대로 정렬 할 수 있다.

### Insertion Sort

 삽입 정렬이란 값을 추가 될 경우 뒤에서 부터 차례대로 비교하면서 적절한 위치를 찾아 삽입하는 정렬 방법이다. 이미 정렬된 배열에 값을 추가하는 방법이라고 할 수 있다. 그렇기 때문에 뒤에서 부터 비교하면서 현재 위치의 값이 추가할 값보다 클 경우 앞으로 이동해서 다시 비교하고, 작거나 같을 경우 현재 위치 뒤에 값을 삽입하면 된다. 그렇기 때문에 이미 순서대로 정렬되어 있을 경우 모든 값이 각각 1번의 비교만 하고 끝나기 때문에 n의 시간 복잡도가 발생하고, 역순으로 정렬되어 있을 경우 1 + 2 + 3 + ... + \(n-1\) 번의 비교를 하기 때문에 n^2의 시간 복잡도가 발생한다.

### Merge Sort

Merge sort는 quick sort와 같이 분할 정복법으로 배열을 반으로 계속 나누고, 나눈 배열을 합치면서 정렬하는 방법이다. nlogn의 시간 복잡도 발

## DB

###  정규화

 데이터베이스 정규화란 데이터베이스의 설계를 재구성하는 테크닉이다. 정규화를 통해 불필요한 데이터\(중복\)를 없앨 수 있고, 삽입/갱/삭제 시 발생할 수 있는 각종 이상현상들을 방지할 수 있다.

![](../.gitbook/assets/image%20%28122%29.png)

*  삽입이상 : 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제이다.  위 그림과 같은 테이블에서 아직 수업을 하나도 수강하지 않은 학생이 있을 경우 수강 과목의 값이 없기 때문에 '미수강' 같은 과목을 새로 만들어서 삽입해야 한다.
* 수정이상 : 중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제를 갱신이상 이라고 한다. 야붕을 컴퓨터공학부에서 음악학부로 옮기게 되는 경우 3개 모두 음악학부로 변경해주어야 한다. 이때 모두 변경하지 않고 두개만 바뀌게 되는 경우 야붕은 컴퓨터공학부인지 음악학부인지 알 수 없게 된다.
* 삭제이상 : 튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제를 삭제이상이라고 한다. 위 테이블에서 모찌는 현재 1개의 과목만 수강하고 있다. 모찌가 수강정정기간에 MEC011101 수업을 듣기 싫어져서 드랍하는 경우, 모찌에 대한 행을 모두 삭제하게 된다. 수강취소를 반영하기 위해 학생등록정보를 모두 날리게 되는 것이다.

 위와 같은 이상현상들이 발생하는 이유는 정규화가 되어 있지 않은 테이블 설계 때문이다. 코딩할 때에도 관심사를 분리하면 코드의 재사용성과 유지보수의 편의성이 높아지는 것처럼 데이터베이스 설계에서도 비슷한 원칙이 적용된다. 

 이론적으로는 정규화를 수행하려면 속성들간의 관련성을 파악해야 하는데, 이 속성들간의 관련성을 **함수적 종속성**\(Functional Dependency\)라고 한다. **일반적으로 하나의 릴레이션에는 하나의 함수적 종속성만이 존재하도록 정규화를 하게 된다.**

###  **함수적 종속성**

x를 키 값으로 y에 모든 원소를 구분할 수 있다는 뜻이다.

 x -&gt; y

* x 는 결정자, y는 종속자라고 한다.
* x 가 y 를 함수적으로 결정한다.
* y 가 x 에 함수적으로 종속되어 있다.

![](../.gitbook/assets/image%20%28124%29.png)

 학번에 의해서 학생이름과 학부는 고유하게 구분되므로 학생이름, 학부 속성은 학번에 함수적으로 종속되어 있다고 할 수 있다. 여기서 학번은 결정자, 학생이름과 학부는 종속자가 되며 함수적 종속성을 `학번 -> (학생이름, 학부)` 라고 할 수 있다.

![](../.gitbook/assets/image%20%28127%29.png)

 학번 -&gt; 이름

{학번, 과목코드} -&gt; 성적

{학번, 과목코드} -&gt; 이름

*  이름을 결정짓는 요소는 학번이다.
*  성적을 결정짓는 요소는 학번과 과목코드이다.
*  이름은 학번과 과목코드에 의해서도 고유하게 구분될 수 있다.

 이름의 경우 해당하는 함수 종속정이 두개다. 여기서 **부분 함수적 종속**과 **완전 함수적 종속**을 구분할 수 있다.

###  부분 함수적 종속

 속정집합 y가 속정집합 x의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미한다.

 이름이 속성집합 y이고, {학번, 과목코드}가 속성집합 x인 상태에서, 이름은 {학번, 과목코드}에도 함수적으로 종속되며 x의 일부인 학번에도 함수적으로 종속된다.

###  완전 함수적 종속

 속성집합 y가 속성집합 x 전체에 대해서만 함수적으로 종속된 경우를 말한다.

 성적이 속성집합 y이고, {학번, 과목코드}가 속성집합 x인 상태에서, 성적은 {학번, 과목코드}의 어떤 부분집합에도 함수적으로 종속되어 있지 않다. 학번만으로 성적을 결정지을 수 없고, 과목코드만으로도 성적을 결정지을 수 없기 때문이다.

 일반적으로 함수적 종속성을 말하면 완전함수종속을 의미한다.

###  제 1 정규형\(1NF : First Normal Form\)

 **릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성되어 있으면 제 1 정규형에 속한다.**

![&#xC81C; 1 &#xC815;&#xADDC;&#xD615;&#xC5D0; &#xB9CC;&#xC871;&#xD558;&#xC9C0; &#xC54A;&#xC74C;](../.gitbook/assets/image%20%28126%29.png)

![&#xC81C; 1 &#xC815;&#xADDC;&#xD615; &#xB9CC;&#xC871;](../.gitbook/assets/image%20%28128%29.png)

###  제 2 정규형\(2NF : Second Normal Form\)

 제 1 정규형만 만족시키는 릴레이션에서 부분 함수 종속성을 가지게 되는 경우 삽입이상, 갱신이상, 삭제이상 세가지 이상현상이 모두 나타나게 된다. 

 **제 1 정규형에 속하면서 , 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제 2 정규형이다.**

![](../.gitbook/assets/image%20%28123%29.png)

 위 릴레이션의 함수적 종속성을 살펴보면 아래와 같다.

* {학번, 과목코드} -&gt; 성적
* {학번, 과목코드} -&gt; 학부
* {학번, 과목코드} -&gt; 등록금
* `학번 -> 학부`
* `학번 -> 등록금`
* 학부 -&gt; 등록

 현재 `학번 -> 학부`, `학번 -> 등록금` 두개의 부분 함수 종속성을 가지고 있다. 이를 제거해 주는 것을 제2 정규화라고 한다.

 학번, 학부, 등록금 속성을 가지는 학생 릴레이션과 학번, 과목코드, 성적 속성을 가지는 성적릴레이션 둘로 나누어 주면 부분 함수 종속성을 제거할 수 있다.

 학번 -&gt; 학부 함수종속성으로 볼때, 학번만으로 학부에 대한 결정을 지을 수 있다는 말이다. 그러나 현재 기본키가 학번, 과목코드로 이루어져 있기 때문에 학번만으로 학부에 대한 결정을 지을 수 있다는 게 의미가 없어진다. 그래서 이를 가능하도록 해주는 과정이 부분 함수 종속성을 제거하는 제 2 정규화 과정이다.

 여기서 학부 -&gt; 등록금 이라는 함수적 종속성은 부분 함수 종속정이 아니다. x -&gt; y라는 함수적 종속성에는 부분 함수 종속성, 완전 함수 종속성을 따질 때 결정자 x가 반드시 기본키나 후보키에 속할 필요는 없으므로 현재 학부 -&gt; 등록금 의 함수 종속성은 하나의 완전 함수 종속이라고 볼 수 있다.

 학번 -&gt; 학부, 학번 -&gt; 등록금 두개의 부분 함수 종속성을 제거하여 분리한 두개의 릴레이션은 아래와 같다.

![](../.gitbook/assets/image%20%28121%29.png)

 정규화 과정에서 주의할 점은 정규화를 통해 분해된 릴레이션들이 조인을 통해 원래의 구조로 복원될 수 있어야 한다는 것이다.

 두 릴레이션 모두 제 1 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되므로 제 2 정규형을 만족한다.

 이상현상을 여전히 존재한다.

*  **삽입이상** : 새로운 학부가 생기는 경우 등록된 학생\(학번\)이 없다면 학번속성이 null이 되므로 삽입할 수 없다.
*  **갱신이상** : 컴퓨터공학부 등록금이 400으로 오르는 경우 위의 경우 둘 모두 바꾸어 주지 않으면 데이터 불일치 문제가 발생한다.
*  **삭제이상** : 21400001 학번을 가진 학생이 자퇴하는 경우, 기계공학부에 대한 정보가 함께 사라진다.

 제 2 정규형에서도 이상현상이 발생하는 이유는 `이행적 함수 종속`이 존재하기 때문이다. 이행적 함수 종속을 없애주는 과정이 제 3 정규화이다.

###  제 3 정규형\(3NF : Third Normal Form\)

 제 2 정규형에 속하면서, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제 3 정규형이다.

####  이행적 함수 종속

 삼단논법 같은 관계를 가진 함수종속이다. x,y,z에 대해 x -&gt; y이고 y -&gt; z가 성립한다. 이를 z가 x에 이행적으로 함수 종속되었다고 한다.

 학생 릴레이션에서 함수적 종속성은 아래와 같다.



*  학번 -&gt; 학부
*  학부 -&gt; 등록금
*  학번 -&gt; 등록

 논리적으로 말은 되는데 의미상 뭔가 이상하다. 학부에 따라 등록금이 결정되는 것이지 학번에 따라 결정되는 것은 아니다. 그냥 이걸 둘로 분리 해주면 된다.

x -&gt; y, y -&gt; z 함수적 종속관계로 인해 x -&gt; z 의 이행적 함수 종속 관계가 나타나면 \[x, y\], \[y, z\] 두 릴레이션으로 분해한다.

![&#xD559;&#xC0DD;, &#xD559;&#xBD80; &#xB9B4;&#xB808;&#xC774;&#xC158;](../.gitbook/assets/image%20%28125%29.png)

 제 3 정규형을 만족해도 이상현상이 없어지는건 아니다. 후보키를 여러개 가지고 있는 릴레이션에서는 제 3 정규형을 만족하더라도 이상현상이 생길 수 있다.

 이를 해결하기 위한 정규형이 보이스-코드 정규형\(BCNF : Boyce-Codd Normal Form\)이다. 제 3 정규형보다 조금 더 엄격한 제약조건을 가지기 때문에 String 3NF 라고도 한다.

###  BCNF\(Boyce - Codd Normal Form\)

  모든 결정자가 KEY인 경우 BCNF이다. 

![](../.gitbook/assets/image%20%28129%29.png)





