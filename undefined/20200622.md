# 20200622

###  절차지향\(Procedural Programming\)

 절차지향 프로그래밍이란 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다. 대표적인 절차지향 언어에는 C언어가 있다.

####  장점

*  컴퓨터의 처리구조와 유사해 실행속도가 빠름

####  단점

*  유지보수가 어려움
* 실행 순서가 정해져 있으므로 코드의 순서가 바뀌면 동일한 결과를 보장하기 어려움
* 디버깅이 어려움

###  객체지향\(Object Oriented Programming\)

 객체지향의 정의를 살펴보면 객체지향이란 실제 세계를 모델링하여 소프트웨어를 개발하는 방법이다. 객체지향 프로그래밍에서는 데이터와 절차를 하나의 덩어리로 묶어서 생각하게 된다. 이는 마치 컴퓨터 부품을 하나씩 사다가 컴퓨터를 조립하는 것과 같은 방법이다. 객체 지향의 4대 특성은 다음과 같다.

*  추상화
  * 추상화란 객체들의 공통적인 특징\(속성과 기능\)을 뽑아내는 것이다. 즉, 우리가 구현하는 객체들이 가진 공통적인 데이터와 기능을 도출해 내는 것을 의미한다.
  *  추상화는 절차지향 프로그래밍에서도 있어왔다. 대표적인 것이 구조체와 같은 사용자 데이터형이다. 이것은 데이터를 추상화해서 하나의 새로운 데이터 유형을 만드는 것이다. 예를들어 struct와 같은 구조체가 있다. 하나의 새로운 데이터형을 정의하는데 그 안에는 여러개의 부속데이터를 둘 수 있다. 이 때 그 데이터를 추상화를 통해 정의한 것이다.
  * class
* 캡슐화
  * 클래스 내부를 외부에 공개하지 않음으로써 외부에서 이 클래스를 맘대로 수정하는 일을 못하게 한다.\(정보은닉\) 클래스 내부에 접근하는 유일한 방법은 public 메소드를 통한 방법 뿐이다. 이 public 메소드는 클래스를 설계한 사람이 만든것이기 때문에 이 클래스가 설계자가 의도한 대로만 동작하게끔 할 수 있다. 만약 멤버 변수가 private가 아닌 public 이어서 정보은닉이 되어 있지 않다면 객체 외부에서 맘대로 멤버 변수를 수정 할 수 있기 때문에 그 멤버 변수를 이곳 저곳에서 참조하게 되면 유지보수가 굉장히 힘들게 될것이다.
  *  데이터 은
* 상속
  * 상속은 이미 작성된 클래스를 이어 받아서 새로운 클래스를 생성하는 기법으로 위에서 말한 기존 코드를 재활용해서 사용하는 것을 의미한다. 객체지향 방법의 큰 장점중 하나.
* 다형성
  * 다형성이란 하나의 이름\(방법\)으로 많은 상황에 대처하는 기법이다. 개념적으로 동일한 작업을 하는 함수들에 똑같은 이름을 부여할 수 있으므로 코드가 더 간단해지는 효과가 있다.
  * 오버라이딩 : 상위클래스의 메소드를 재정의
  * 오버로딩 : 다른 매개변수로 다수의 메소드를 중복정

 위의 특성들로 인해 생기는 객체지향 방법의 장점은 다음과 같다.

*  신뢰성 있는 소프트웨어를 쉽게 작성할 수 있다.
* 코드를 재사용하기 쉽다.
* 업그레이드가 쉽다.
* 디버깅이 쉽다.
* 유지보수가 쉽다.

 이론적으로만 보면 객체지향 언어는 절차지향 언어에 비해 장점이 많다. 하지만 프로그래밍을 할 때 항상 객체지향 언어만 사용하는 것은 아니다. 객체지향 언어는 어떤 모듈에 있는 하나의 기능만 필요하더라도 모듈 전체를 가져와야 하기 때문에 절차지향 프로그래밍보다 프로그램 사이즈가 더 커질 수도 있다. 또한 데이터에 대한 접근도 상대적으로 절차지향식보다 느려질 가능성이 많다. 메소드를 통해서만 접근이 가능하기 때문에 절차지향식처럼 특정 함수에 접근할 수  없고, 식으로만 접근이 가능해 속도적인 측면에서 불이익이 있다.

####  장점

*  코드의 재활용성이 높음
* 코딩이 절차지향보다 간편함
* 디버깅이 쉬움

####  단점

* 처리속도가 절차지향보다 느림
* 설계에 많은 시간소요가 들어감

###  객체지향과 절차지향의 차이점

 객체지향의 반대는 절차지향이 아니고 절차지향의 반대는 객체지향이 아니다. 절차지향은 순차적으로 실행에 초점이 되어있고 객체지향은 객체간의 관계/조직에 초점을 두고 있다. 객체지향 역시 절차지향과 동일한 순서로 실행된다.

![](../.gitbook/assets/image%20%28135%29.png)

 절차지향은 데이터를 중심으로 함수를 구현한다. 이에 반해 객체지향은 기능을 중심으로 메서드를 구현하게 된다.

{% embed url="https://m.blog.naver.com/PostView.nhn?blogId=atalanta16&logNo=220249264429&proxyReferer=https:%2F%2Fwww.google.com%2F" %}

###  객체지향 5원칙 SOLID

 객체지향의 4대 특성인 캡슐화, 상속, 추상화, 다형성을 이용하여 객체 지향을 올바르게 설계할 수 있도록 도와주는 원들이다. SOLID 원칙들은 자기 자신 클래스 안에 응집도는 내부적으로 높이고, 타 클래스들 간 결합도는 낮추는 High Cohesion - Loose Coupling 원칙을 객체 지향의 관점에서 도입한 것이다. 이렇게 설계된 소프트웨어는 재사용이 많아지고, 수정이 최소화 되기 때문에 결국 유지 보수가 용이해진다.

####  SRP\(단일책임의 원칙 : Single Responsibility Principle\)

 **소프트웨어의 설계 부품\(클래스, 함수\)은 단 하나의 책임\(기능\)만 가져야 한다.**

* 설계를 잘한 프로그램은 기본적으로 새로운 요구사항과 프로그램 변경에 영향을 받는 부분이 적다. 다시말해, 응집도는 높고 결합도는 낮은 프로그램을 뜻한다. 만약 한 클래스가 수행할 수 있는 기능, 즉 책임이 많아지면 클래스 내부의 함수끼리 강한 결합을 발생할 가능성이 높아진다. 이는 유지보수에 비용이 증가하게 되므로 따라서 책임을 분리시킬 필요가 있다.



*  작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙이다. 이는 어떤 변화에 의해 클래스를 변경해야하는 이유는 오직 하나뿐이어야 함을 의미한다. 

####  OCP\(개방폐쇄의 원칙 : Open Close Principle\)

 **기존의 코드를 변경하지 않고\(Close\) 기능을 수정하거나 추가할 수 있도록\(Open\) 설계해야 한다.**

*  OCP에 만족하는 설계를 할 때 변경되는 것이 무엇인지에 초점을 맞춘다. 자주 변경되는 내용은 수정하기 쉽게 설계하고, 변경되지 않아야 하는 것은 수정되는 내용에 영향을 받지 않게 하는 것이 포인트다. 이를 위해 자주 사용되는 문법이 인터페이스\(Interface\)이다. \(ex  Strategy Pattern\)

![](../.gitbook/assets/image%20%28136%29.png)

SoundPlayer 클래스는 음악을 재생해주는 클래스이다. 이 클래스는 기본적으로 wav 파일을 재생할 수 있다. 그러나 SoundPlayer가 다른 포맷의 파일, 예를 들어 mp3 파일을 재생하도록 요구사항이 변경 되었다고 하자. 요구사항을 만족시키기 위해서는 SoundPlayer의 play\(\) 메소드를 수정하여야 한다. 그러나 이러한 소스코드 변경은 OCP 원칙에 위배된다.

 OCP 원칙을 만족시키기 위해서는 다양한 방법이 있지만 여기선 인터페이스를 이용하여 OCP를 만족시켜보자. 먼저 변해야 하는 것은 무엇인지 정의한다. 위 클래스에서는 play\(\)메소드가 변해야 하는 것이다. play\(\)메소드를 인터페이스로 분리한다.

![](../.gitbook/assets/image%20%28138%29.png)

 일단 재생하고자 하는 파일 클래스\(wav, mp3\)를 만들어 PlayAlgorithm 인터페이스의 play\(\) 메소드를 재정의하도록 설계한다.

![](../.gitbook/assets/image%20%28137%29.png)

 SoundPlayer 클래스에서는 playAlgorithm 인터페이스를 멤버 변수로 만든다. 그 후 SoundPlayer의 play\(\) 함수는 인터페이스를 상속받아 구현된 클래스의 play\(\)함수를 실행시키게 한다. 마지막으로 메인함수에 setter를 이용하여 우리가 플레이하고자 하는 파일의 객체를 지정해주면 된다. 이와 같은 설계를 디자인 패턴에서는 Strategy Pattern\(전략 패턴\)이라고 한다

결과적으로 우리는 SoundPlayer 클래스의 변경 없이 재생되는 파일을 바꿀 수 있으므로 위 코드는 OCP를 만족한다. OCP를 만족한 설계는 변경에 유연하므로 유지보수 비용을 줄여주고 코드의 가독성 또한 높아지는 효과를 얻을 수 있다.



*  소프트웨어의 구성요소\(컴포넌드, 클래스, 모듈, 함수\)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리이다. 이것은 변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화 해야 한다는 의미로, 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻이다. OCP는 관리가능하고 재사용 가능한 코드를 만드는 기반이며, OCP를 가능케 하는 중요 메커니즘은 추상화와 다형성이라고 설명하고 있다. OCP는 객체지향의 장점을 극대화하는 아주 중요한 원리라고 할 수 있다.

#### LSP\(리스코브 치환의 원칙 : The Liskov Substitution Principle\)

 **자식 클래스는 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다.\(사용자의 관점에서 기능에 영향을 미치지 않고 서브 클래스를 부모 클래스로 대체 할 수 있어야 한다.\)**

*  리스코프 치환 원칙은 MIT 컴퓨터 사이언스 교수인 리스코프가 제안한 설계 원칙이다. 부모 클래스와 자식 클래스 사이의 행위에는 일관성이 있어야 한다는 원칙이며, 이는 객체 지향 프로그래밍에서 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용해도 문제가 없어야 한다는 것을 의미한다.
* 상속 관계에서는 일반화 관계\(IS - A\)가 성립해야 한다. 일반화 관계에 있다는 것은 일관성이 있다는 것이다. 따라서 리스코프 치환 원칙은 일반화 관계에 대해 묻는 것이라 할 수 있다.

 예를 들어 도형 클래스와 사각형 클래스가 있고, 사각형 클래스는 도형 클래스의 상속을 받는다고 가정하자.

1.  도형은 둘레를 가지고 있다.
2.  도형은 넓이를 가지고 있다.
3.  도형은 각을 가지고 있다.

일관성인지 확인하는 방법은 단어를 교체해 보면 알 수 있다. 1 - 3의 도형이란 단어 대신 사각형을 넣어보자

1.  사각형은 둘레를 가지고 있다.
2.  사각형은 넓이를 가지고 있다.
3.  사각형은 각을 가지고 있다.

1 - 3 모두 딱히 이상한 부분이 보이지 않는다. 따라서 도형과 사각형 사이에는 일관성이 있다고 할 수 있다.

 여기서 원이라는 도형에 대해 생각해보자. 원 클래스 역시 도형 클래스의 상속을 받는다고 가정하자. 앞에서 언급한 1 - 3의 도형 단어 대신 원을 대입했을 경우 3번 문장이 어색하다는 것을 알 수 있다. 따라서 도형 클래스는 LSP을 만족하지 않는 설계라 할 수 있다. 따라서 3번 문장에 대해서는 일반화 관계가 성립하도록 수정되어야 한다.

 LSP를 한마디로 한다면, "서브 타임은 언제나 기반 타입으로 교체할 수 있어야 한다."라고 할 수 있다. 즉, 서브 타입은 언제나 기반 타입과 호환될 수 있어야 한다.

#### ISP\(엔터페이스 분리의 원칙: Interface Segregation Principle\)

 **한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 범용적 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다.**

 이는 다시 말해서, 자신이 사용하지 않는 기능\(인터페이스\)에는 영향을 받지 말아야 한다는 의미이다.

 한가지 예를 들어보자, 우리는 스마트폰으로 전화, 웹서핑, 사진 촬영 등 다양한 기능을 사용할 수 있다. 그런데 전화를 할 때에는 웹서핑, 사진촬영 등 다른 기능은 사용하지 않는다. 따라서 전화기능과 웹서핑 기능 사진 촬영 기능은 각각 독립된  인터페이스로 구현하여, 서로에게 영향을 받지 않도록 설계해야 한다. 이렇게 설계된 소프트웨어는 인터페이스 분리 원칙을 통해 시스템의 내부 의존성을 약화시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있다.

*  ISP원리는 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리이다. 즉 어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용해야 한다. ISP를 '하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다'라고 정의할 수 있다.

{% embed url="https://limkydev.tistory.com/77" %}

**`"하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다."`**

####  DIP\(의존성역전의 원칙 : Dependency Inversion Principle\)

 **의존 관계를 맞을 때, 변화하기 쉬운것 보단 변화하기 어려운 것에 의존해야 한다는 원칙이다.**

 여기서 말하는 변화하기 쉬운것이란 구체적인 것을 말하고, 변화하기 어려운 것이란 추상적인 것을 말한다. 객체지향적인 관점에서 보자면 변화하기 쉬운것이란 구체화 된 클래스를 의미하고, 변화하기 어려운 것은 추상클래스나 인터페이스를 의미한다. 따라서 DIP를 만족한다는 것은 의존관계를 맺을 때, 구체적인 클래스보단 인터페이스나 추상클래스와 관계를 맞는다는 것을 의미한다.

DIP를 만족하면 '의존성 주입'이라는 기술로 변화에 유연한 설계를 할 수 있다. 앞에 언급한 SoundPlayer 클래스를 다시 보자

![](../.gitbook/assets/image%20%28139%29.png)

 우리는 setFile 클래스를 이용하여 실행하고자 하는 파일을 쉽게 바꿀 수 있다. 마찬가지로 새로운 오디오 파일 포맷\(예를 들어 FLAC\)을 실행시키고자 한다면, 새로운 클래스\(FLAC\)를 만든 후 play 인터페이스를 상속받아 구현한 후 setFile 메소드를 이용하여 file 멤버 변수에 주입시기면 된다. 이와 같은 기술을 '의존성 주입'이라 한다.

####  의존 역전 원칙 이해

 자신보다 변하기 쉬운 것에 의존하면 안된다는 것이다. 추상클래스 또는 상위 클래스는 구체적인 구현클래스 또는 하위 클래스에게 의존적이면 안된다. 왜냐하면 구체적인 클래스는 코딩에 있어서 가장 전면적으로 노출되고 사용되기 때문에 변화에 민감하다. 만약 DIP에 의해서 설계하지 않는다면, 구체화된 클래스가 수정될 때마다 상위클래스나 추상클래스가 변화해야 하는데 또 그 상위 또 그 상위 계속 연관 되어 있는 클래스들이 수정되어야 한다. 따라서 하위클래스나 구체클래스에게 의존하면 안된다.

{% embed url="https://limkydev.tistory.com/77" %}

## 컴네

### http & https

#### http

 하이퍼 텍스트 전송 프로토콜의 약자로 서로 다른 시스템들 사이에 통신을 주고받게 해주는 가장 기초적인 프로토콜. http는 단순 텍스트를 주고 받기 때문에 누군가 네트워크에서 신호를 가로채어 본다면 내용이 노출된다. 이런 보안상의 문제를 해결해주는 프로토콜이 https다.

#### https

 하이퍼 텍스트 전송 프로토콜 보안의 약자이다. 일반 http의 문제점은 서버에서부터 브라우저로 전송되는 정보가 암호화되지 않는다는 것이다. 이말은 즉, 데이터가 쉽게 도난당할 수 있다는 것이다. http는 ssl을 사용함으로써 이 문제를 해결했다. ssl은 서버와 브라우저 사이에 안전하게 암호화된 연결을 만들 수 있게 도와주고, 서버 브라우저가 민감한 정보를 주고 받을 때 이것이 도난당하는 것을 막아준다.

* https는 http메시지\(text\)를 암호화하는 것이다.
* https는 s가 Secure Socket, 보안 통신망을 말한다.
* https의 암호화 원리를 간단히 알아보면 핵심은 공개키 암호화 방식이다.

####  http vs https

 https 암호화를 하려면 웹 서버 부하가 생기고 공개키 인증서를 위해 업체에 비싼 돈을 지불해야한다. 

###  대칭키 암호

*  하나의 비밀키를 양쪽\(client, server\)가 모두 같이 사용
* 암호화와 복호화에 사용하는 키가 같은 암호화 알고리즘
* 공개키와 비밀키를 별도로 가지는 것과 구별되는데, 이와 비교하면 계산속도가 빠르다는 장점
* 비밀키 하나만 알아내면 암호화된 내용을 해독 가능 -&gt; 해커로부터 안전 x
* 대칭키 암호는 암호화하는 단위에 따라 스트림암호화 블록암호로 나눌 수 있음
  * 스트림암호는 연속적인 비트/바이트를 계속해서 입력받아, 그에 대응하는 암호화 비트/바이트를 생성하는 방식
  * 블록암호는 정해진 한 단위\(블록\)을 입력 받아 그에 대응하는 암호화 블록을 생성하는 방식
  * 블록암호의 경우 적절한 운용모드를 조합하면 블록 단위보다 큰 입력을 처리할 수 있음. 또한 스트림암호와 유사하게 지속적인 입력에 대해 동작할 수 있음.\(대신 입출력 단위는 스트림암호보다 큰 블록 단위가 됨\)
* 대칭키 기법을 사용하는 암호 알고리즘 방식으로 DES, 3-DES, AES, SEEDM ARIA, MASK등이 있다.

###  공개키 암호

* 비밀키 하나만 가지는 대칭키 암호 방법과 달리, 공개키와 비밀키 두개가 존재
* 공개키 암호를 구성하는 알고리즘을 대칭키 암호 방식과 비교하여 비대칭 암호라고 불림
* 암호화와 복호화에 사용하는 키가 서로 다름
* 암호화할 때의 키는 공개키, 복호화할 때의 키는 개인키
* 공개키는 누구나 알 수 있지만, 그에 대응하는 비밀키는 키의 소유자만이 알 수 있어서 특정한 비밀키를 가지는 사용자만이 내용을 열어볼 수 있도록 하는 방식

 송신자는 수신자의 공개키를 받아 데이터를 암호화하여 네트워크를 통해 원격지에 전달. 수신자는 공개키로 암호화된 데이터를 자신의 개인키로 데이터를 복호화하여 평문을 복원.

* 공개키로 암호화한 메세지는 수신자의 개인키로만 해독할 수 있으므로 안전하게 상대방에게 메세지를 전달해 줄 수 있음.
* 대칭키 알고리즘에 비하여 속도가 느리다.\(약 1000배\)
* 대표적인 공개키 알고리즘으로 RSA, Elgamal 등이 있음.



