# 20200621

##  자료구조

###  BST\(Binary Search Tree\)

 이진탐색트리란 이탐색\(binary search\)과 연결리스트\(linked list\)를 결합한 자료구조의 일종이다. 이진탐색의 효율적인 탐색 능력을 유지하면서도, 빈번한 자료 입력과 삭제를 가능하게끔 고안되었다.

*  각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 이루어져 있다.
*  각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 이루어져 있다.
*  중복된 노드가 없어야 한다.
*  왼쪽 서브트리, 오른쪽 서브트리 또한 이진탐색트리이다.

 이진탐색트리를 순회할때는 중위순회\(inorder\) 방식을 쓴다.\(왼쪽 서브트리 - 노드 - 오른쪽 서브트리 순으로 순회\) 이렇게 하면 이진탐색트리 내에 있는 모든 값들을 정렬된 순서대로 읽을 수 있다. 

![](../.gitbook/assets/image%20%28133%29.png)

####  search

 찾고자하는 값과 현재 노드의 값을 비교하면서 현재 노드의 값이 찾고자하는 값보다 클 경우 왼쪽 자식노드로 이동하고, 작을 경우 오른쪽 자식노드로 이동하여 다시 비교한다. 만약 자식노드가 없을 경우 찾고자 하는 값이 없다고 반환하고 탐색을 종료한다.

  이진탐색트리의 탐색 연산에 소요되는 시간복잡도는 트리의 높이 h 라고 할 수 있다.

####  insert

 삽입 연산은 leaf노드에서 이루어진다. 탐색과 마찬가지로 삽입하고자 하는 값이 현재 노드의 값보다 클 경우 오른쪽 자식노드로 이동하고 아니면 왼쪽 자식노드로 이동한다. 이동하고자 하는 노드가 없을 경우 해당 위치에 값을 삽입한다.

 삽입 연산도 삽입할 위치의 leaf노드까지 찾아 내려가는데 h번 비교를 해야하기 때문에 시간 복잡도는 O\(h\)라고 할 수 있다.

#### delete

 삭제연산은 탐색, 삽입보다는 약간 복잡하다. 삭제 결과로 이진탐색트리의 속성이 깨질 수 있기 때문이다.

*  삭제할 노드에 자식노드가 없는 경우 : 해당 노드를 그냥 없애기만 하면 된다.

![42 &#xC0AD;&#xC81C;](../.gitbook/assets/image%20%28134%29.png)

*  삭제할 노드에 자식노드가 하나 있을 경우 : 해당 노드를 지우고, 해당 노드의 자식노드와 부모노드를 연결해주면 된다.

![20 &#xC0AD;&#xC81C;](../.gitbook/assets/image%20%28131%29.png)

*  삭제할 노드에 자식노드가 두 개 있는 경우

 predecessor : 삭제 대상 노드의 왼쪽 서브트리 가운데 최대값

successor : 삭제 대상 노드의 오른쪽 서브트리 가운데 최소

 삭제 노드에 successor를 복사하고, successor를 삭제한다.

![16 &#xC0AD;&#xC81C;](../.gitbook/assets/image%20%28132%29.png)

 이진탐색트리 구조상 successor\(삭제 대상 노드의 오른쪽 서브트리의 최소값\)는 자식노드가 하나이거나 하나도 존재하지 않는다.

1.  삭제 대상 노드의 오른쪽 서브트리의 최소값을 찾는다. \(successor\)
2.  successor의 값을 삭제 대상 노드에 복사한다.
3.  successor 노드를 삭제한다.

 삭제도 마찬가지로 O\(h\)의 시간복잡도를 가진다.

####  한계점

 이진탐색트리의 탐색 시간복잡도는 일반적으로 h인 O\(logN\)이지만, 극단적으로 n개의 노드가 크기순으로 일렬로 늘어뜨려져 높이 또한 n이 되는 경우 O\(N\)이 된다.



