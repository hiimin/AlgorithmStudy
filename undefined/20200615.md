# 20200615

##  운영체제

###  스케쥴링

* 스케쥴링은 프로세스가 생성되어 실행될 때 필요한 시스템의 여러자원을 해당 프로세스에게 할당하는 작업을 의미한다. 
* 프로세스가 생성되어 완료될때까지 프로세스는 여러 종류의 스케쥴링 과정을 거치게 된다.
* 스케쥴링의 종류에는 장기 스케쥴링, 중기 스케쥴링, 단기 스케쥴링이 있다.

####  장기 스케쥴링

 어떤 프로세스가 시스템의 자원을 차지할  있도록 할 것인가를 결정하여 준비상태 큐로 보내는 작업을 의미한다. 작업 스케줄링, 상위 스케줄링이라고도 하며, 작업 스케쥴러에 의해 수행된다.

*  메모리와 디스크 사이의 스케쥴링 담당
* 프로세스에 memory를 할당
*  몇 개의 프로그램이 올라갈 것인지를 제어
* new -&gt; ready

####  중기 스케줄링

 어떤 프로세스들이 CPU를 할당 받을 것인지 결정하는 작업을 의미한다. CPU를 할당 받으려는 프로세스가 많을 경우 프로세스를 일시 보류시킨 후 활성화해 일시적으로 부하를 조절한다.

*  여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄\(swapping\)
* 프로세스에게서 memory를 deallocate
* 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러
* ready -&gt; suspended

####  단기 스케쥴링

 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업을 의미한다. 프로세서 스케쥴링, 하위 스케쥴링이라고도 한다. 프로세스 스케쥴링 및 문맥 교환은 프로세서 스케줄러에 의해 수행된다.

*  CPU와 메모리 사이의 스케쥴링을 담당
* Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정
* 프로세스에 CPU 할당
* ready -&gt; running -&gt; waiting -&gt; ready

### CPU 스케줄러

 스케줄링 대상은 ready Queue에 있는 프로세스들이다.

CPU가 일을 수행하는 시간을 CPU burst time 이라고 한다.

#### FCFS\(First Come First Served\)

*  먼저 온 고객을 먼저 서비스해주는 방식, 즉 먼저 온 순서대로 처리
*  비선점형 스케줄링
*  일단 CPU를 잡으면 CPU burst가 완료될 때까지 CPU를 반환하지 않는다. 할당되었던 CPU가 반환될 때만 스케줄링이 이루어진다.
*  문제점 : 소요시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상이 발생한다.

#### SJF\(Shortest - Job - First\)

*  다른 프로세스가 먼저 도착했어도 CPU burst time이 짧은 프로세스에게 선 할당
* 비선점형\(Non - Preemptive\) 스케줄링
* 문제점 : 효율성을 추구하는게 가장 중요하지만 특정 프로세스가 지나치게 차별받으면 안되는 것이다. 이 스케쥴링은 극단적으로 CPU 사용이 짧은 job을 선호한다. 그래서 사용 시간이 긴 프로세스는 거의 영원히 CPU를 할당 받지 못하는 starvation이 발생한다.

#### SRT\(Shortest Remaining time First\)

*  새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
*  선점형\(Preemptive\) 스케줄링
* 현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 뺏긴다.
* 문제점 : starvation, 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time을 측정할 수가 없다.

#### Priority Scheduling

*  우선순위가 가장 높은 프로세스에게 CPU를 할당한다. 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높다.
* 선점형 스케줄링 방식 : 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU를 선점한다.
* 비선점형 스케줄링 방식 : 더 높은 우선순위의 프로세스가 도착하면 Ready Queue의 Head에 넣는다.
* 문제점 : starvation, 무기한 봉쇄 : 실행 준비는 되었으나 CPU를 사용못하는 프로세스를 CPU가 무기한 대기하는 상
* 해결책 : aging - 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주는 것.

 우선순위 기준

 내부적 요인\(측정 가능한 변수\) : 시간 제한, 메모리 요구량, I/O 처리 시간, CPU 처리 시간

 외부적 요인\(바깥에 이미 설정된 기\) : 프로세스의 중요도, 자원의 유형, 자원의 비용, 사용자 선호도

####  Round Robin

*  현대적인 CPU 스케줄링
* 각 프로세스는 동일한 크기의 할당 시간을 갖게 된다.
* 할당 시간이 지나면 프로세스는 선점당하고 ready queue의 제일 뒤에 가서 다시 줄을 선다.
* CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우 효율적
* Round Robin이 가능한 이유는 프로세스의 context를 save할 수 있기 때문
* 일정한 시간을 time quantum이라고 하는데 time quantum의 크기가 무한에 가깝게 설정한다면 FCFS와 동일하게 동작하고, 반대로 0에 가깝게 설정하면 switching overhead가 매우 증가하여 비효율적이다. 결과적으로 적당한 시간을 설정해줘야 하는데 일반적으로 10 - 100msec으로 정한다.



