# hashing

## Hash Table

* 해쉬 테이블은 dynamic set을 구현하는 효과적인 방법의 하나
  * 적절한 가정하에서 평균 탐색, 삽입, 삭제시간 O\(1\) 보통 최악의 경우 Θ\(n\)
  * 보통 최악의 경우 Θ\(n\)



* 해쉬 함수\(hash function\) h를 사용하여 키 k를 T\[h\(k\)\]에 저장
  * h : U → {0,1,...,m-1}, 여기서 m은 테이블의 크기, U는 모든 가능한 키들의 집합
  * 키 k가 h\(k\)로 해슁되었다고 말함

![](../.gitbook/assets/image%20%2816%29.png)

##  해쉬 함수

* 모든 키들을 자연수라고 가정. 어떤 데이터든지 자연수로 해석하는 것이 가능
* 예: 문자열
  * ASCII 코드: C=67, L=76, R=82, S=83.
  * 문자열 CLRS는 \(67·128³\)+\(76·128²\)+\(82·128¹\)+\(83·128º\)=141,764,947
* 해쉬 함수의 간단한 예:
  * h\(k\) = k % m, 즉 key를 하나의 자연수로 해석한 후 테이블의 크기 m으로 나눈 나머지
  * 항상 0~m-1 사이의 정수가 됨

##  충돌\(collision\)

* 두 개 이상의 키가 동일한 위치로 해슁되는 경우
* 즉, 서로 다른 두 키 k1과 k2에 대해서 h\(k1\)=h\(k2\)인 상황 
* 일반적으로 \|U\|&gt;&gt;m이므로 항상 발생 가능 \(즉 단사함수가 아님\)
* 만약 \|K\|&gt;m라면 당연히 발생, 여기서 K는 실제로 저장된 키들의 집합
* 충돌이 발생할 경우 대처 방법이 필요 
* 대표적인 두 가지 충돌 해결 방법: chaining과 open addressing

![](../.gitbook/assets/image%20%283%29.png)

###  Chaining에 의한 충돌 해결

* 동일한 장소로 해슁된 모든 키들을 하나의 연결리스트\(Linked List\) 로 저장

![](../.gitbook/assets/image%20%2881%29.png)

* 키의 삽입\(Insertion\)
  * 키 k를 리스트 T\[h\(k\)\]의 맨 앞에 삽입: 시간복잡도 O\(1\) 
  * 중복된 키가 들어올 수 있고 **중복 저장이 허용되지 않는다면** 삽입시 리스트를 검색해야 함. 따라서 시간복잡도는 **리스트의 길이에 비례**
* 키의 검색\(Search\)
  * 리스트 T\[h\(k\)\]에서 **순차검색**
  * 시간복잡도는 키가 저장된 **리스트의 길이에 비례.**
* 키의 삭제\(Deletion\)
  * 리스트 T\[h\(k\)\]로 부터 키를 검색 후 삭제
  * 일단 키를 검색해서 찾은 후에는 O\(1\)시간에 삭제 가능



* 최악의 경우는 모든 키가 하나의 슬롯으로 해슁되는 경우
  * 길이가 n인 하나의 연결리스트가 만들어짐
  * 따라서 최악의 경우 탐색시간은 Θ\(n\)+해쉬함수 계산시간
* 평균시간복잡도는 키들이 여러 슬롯에 얼마나 잘 분배되느냐에 의해서 결정

### SUHA \(Simple Uniform Hashing Assumption\)

* 각각의 키가 모든 슬롯들에 균등한 확률로\(eually likely\) 독립적으로 \(independently\) 해슁된다는 가정
  * 성능분석을 위해서 주로 하는 가정임
  * hash함수는 deterministic하므로 현실에서는 불가능\(random하지 않음\)
* Load factor α = n/m:
  * n: 테이블에 저장될 키의 개수. 
  * m: 해쉬테이블의 크기, 즉 연결리스트의 개수 
  * 각 슬롯에 저장된 키의 평균 개수
* 연결리스트 T\[j\]의 길이를 nj라고 하면 E\[nj\] = α
* 만약 n=O\(m\)이면 평균검색시간은 O\(1\)

### Open Addressing에 의한 충돌 해결

* 모든 키를 해쉬 테이블 자체에 저장 
* 테이블의 각 칸\(slot\)에는 1개의 키만 저장 
* 충돌 해결 기법
  * Linear probing 
  * Quadratic probing 
  * Double hashing

### Open Addressing - Linear Probing

![](../.gitbook/assets/image%20%2886%29.png)

h\(k\), h\(k\)+1, h\(k\)+2,… 순서로 검사하여 처음으로 빈 슬롯에 저장 테이블의 끝에 도달하면 다시 처음으로 circular하게 돌아감

* Linear probing의 단점
  * primary cluster: 키에 의해서 채워진 연속된 슬롯들을 의미\(뭉쳐있는 뭉텅이\)
  * 이런 cluster가 생성되면 이 cluster는 점점 더 커지는 경향이 생김
* Quadratic probing 
  * 충돌 발생시 `h(k), h(k)+12, h(k)+22, h(k)+32,...` 순서로 시도
* Double hashing 
  * 서로 다른 두 해쉬 함수 h1과 h2를 이용하여 `h(k,i) = (h1(k) + i·h2(k)) mod m`

### Open Addressing - Quadratic Probing

충돌 발생시 h\(k\), h\(k\)+12, h\(k\)+22, h\(k\)+32,... 순서로 시도

![](../.gitbook/assets/image%20%2814%29.png)

### Open Addressing - Double hashing

![](../.gitbook/assets/image%20%2818%29.png)

### Open Addressing - 키의 삭제

* 단순히 키를 삭제할 경우 문제가 발생
  * 가령 A2, B2, C2가 순서대로 모두 동일한 해쉬함수값을 가져서 linear probing으로 충돌 해결\(왼쪽 그림\)
  * B2를 삭제한 후\(가운데 그림\) C2를 검색
  * C2를 검색하면 A2 다음을 확인하게 되고, 없는 값으로 판단 됨

![](../.gitbook/assets/image%20%2832%29.png)

###  좋은 해쉬 함수란

* 현실에서는 키들이 랜덤하지 않음 
* 만약 키들의 통계적 분포에 대해 알고 있다면 이를 이용해서 해쉬 함수를 고 안하는 것이 가능하겠지만 현실적으로 어려움 
* 키들이 어떤 특정한 \(가시적인\) 패턴을 가지더라도 해쉬함수값이 불규칙적이 되도록 하는게 바람직 
  * 해쉬함수값이 키의 특정 부분에 의해서만 결정되지 않아야

### Division 기법

* h\(k\) = k mod m 
* 예: m = 20 and k = 91 ⇒ h\(k\) = 11. 
* 장점: 한번의 mod연산으로 계산. 따라서 빠름. 
* 단점: 어떤 m값에 대해서는 해쉬 함수값이 키값의 특정 부분에 의해서 결정 되는 경우가 있음. 가령 m=2p 이면 키의 하위 p비트가 해쉬 함수값이 됨.

### Multiplication 기법

* 0에서 1사이의 상수 A를 선택: 0&lt;A&lt;1. 
* kA의 소수부분만을 택한다. 
* 소수 부분에 m을 곱한 후 소수점 아래를 버린다. 
* 예: m=8, word size = w = 5, k = 21. 
  * A = 13/32를 선택
  * kA = 21⋅13/32 = 273/32 = 8 + 17/32 
  * m \(kA mod 1\) = 8 · 17/32 = 17/4 = 4.··· 
  * 즉, h\(21\) = 4

